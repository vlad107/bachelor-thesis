\chapter{Постановка задачи}
\startrelatedwork

\section{Мотивация}
Систему для автоматического доказательства теорем можно рассматривать как совокупность небольших подсистем (акторов). В этой системе каждый актор:
\begin{enumerate}
	\item Получает некоторые формулы от других акторов
    \item Выделяет из них подформулы, на которых он специализируется (например только часть с предикатами из заданного множества)
    \item Делает выводы из формул по своей специализации
    \item сообщает эту информацию другим акторам (следующему по кругу, либо всем, либо по какому-нибудь заданному алгоритму)
\end{enumerate} \par
Интуитивная мотивация такого подхода происходит из социиологии, где люди не решают сложные задачи поодиночке. Например, если у меня болит горло, то я сделаю некоторые допущения о своём состоянии и обращусь к доктору. Таким образом, у каждой сущности есть небольшое подмножество задач, соответсвующих специализации этой сущности. А решение задачи происходит в процессе коммуникации сущностей.

% TOOD: нужно больше.

\section{Формальное построение модели}

\subsection{Описание акторов}

Так как у каждого актора есть внутреннее состояние, то мы можем определять функции и предикаты, зависящие от номера актора. На данный момент будем считать, что функции заданы заранее, однако в части %TODO: \ref{sec:DCRdyn}
опишем вариант с динамическим изменением специализации.

\begin{definition}
  \emph{Специализация.} Пусть $A = \{A_1, A_2, \ldots, A_N\}$ --- множество из $N$ акторов. 
  Тогда семейство предикатов $\{\Xi_{i}\}_{i \in \{1,\ldots,N\}}$, заданных на множестве литералов $LIT$, 
  называется \emph{специализацией} актора. \par
  
  Будем говорить, что актор $i$ \emph{специализируется} на литерале $\ell$, если верно $\insp{i}{\ell}$.
\end{definition}

\begin{definition}
	\emph{Остаточный клоз.} Пусть $C = \ell_1 \vee \ldots \vee \ell_n$ -- клоз. Тогда $rem_a(C) = \ell_{i_1} \vee \ldots \vee \ell_{i_k}$ -- остаточный клоз внутри актора $a$, если 
\end{definition}

%% TODO: изменение этой функции в процессе доказательства, т.к. у акторов есть функция become, которая изменяет поведение актора.

\subsection{Описание Distributed Conflict Resolution исчисления}

На рисунке \ref{fig:DCR} показаны правила для обобщённого на распределённый случай исчисления \emph{Conflict Resolution}, которое было описано в секции \ref{sec:CR}. \par

На правила вывода накладываются следующие дополнительные условия:
\begin{enumerate}
	\item \emph{Unit-Propagation Resolution.}
    \begin{itemize}
    	\item ${\ell^i_1, \ldots, \ell^i_n, \ell'^i_1, \ldots, \ell'^i_n, \ell}$ -- литералы из актора $i$, т.е. для любого $k$ верно, что $\insp{i}{\ell^i_k}$, $\insp{i}{\ell'^i_k}$, $\insp{i}{\ell^i}$
        \item $\sigma$ -- унификатор для $\ell^i_k$ и $\ell'^i_k$ при всех $k \in \{1, \ldots, n \}$ 
        \item $\jmath^i = \jmath^i_1 \vee \ldots \vee \jmath^i_m$, причём $\overline{\insp{i}{\jmath^i_k}}$ для всех $k \in \{1, \ldots, m\}$
    \end{itemize}
        
	\item \emph{Cofnlict.}
    \begin{itemize}
        \item $\ell^i, \ell'^i$ -- литералы из актора $i$, т.е. верно $\insp{i}{\ell^i_k}$ и $\insp{i}{\ell'^i_k}$
    	\item $\sigma$ -- унификатор $\ell$ и $\ell'$
    \end{itemize}
        
    \item \emph{Conflict-Driven Clause Learning.}
    \begin{itemize}
    	\item ${\ell^i_1, \ldots, \ell^i_n, \ell'^i_1, \ldots, \ell'^i_n, \ell}$ -- литералы из актора $i$, т.е. для любого $k$ верно, что $\insp{i}{\ell^i_k}$, $\insp{i}{\ell'^i_k}$, $\insp{i}{\ell^i}$
        
		\item $\overline{\insp{i}{\jmath^i_k}}$ для всех $k \in \{1, \ldots, m\}$ 

		\item $\sigma^k_j$ (для $1 \leq k \leq n$ и $1 \leq j \leq m_k$) -- это
композиция всех подстановок, использованных на $j$-ом пути \footnote{Так как
  доказательство -- это ориентированный ациклический граф, который возможно не
  является деревом, то может существовать несколько путей, соединяющих $\ell^i_k$ и
  $\jmath$ в доказательстве.} от $\ell^i_k$ до $\jmath = \jmath^i_1 \vee \ldots \vee \jmath^i_m$
  
  		\item  $\sigma'^k_j$ (для $1 \leq k \leq m$ и $1 \leq j \leq m'_k$) -- это
композиция всех подстановок, использованных на $j$-ом пути от $\jmath^i_k$ до $\jmath$
    \end{itemize}
    
    \item \emph{Konwledge sharing.}
    	На данном этапе не будем описывать дополнительных условий для этого правила вывода, однако в секции \ref{sec:restr} будут рассмотрены идеи ограничений, которые помогут нам ускорить реализацию данного алгоритма.

\end{enumerate}

\subsection{Рассмотрение возможных ограничений на правило \emph{ks}}
\label{sec:restr}

\begin{figure}\begin{calculus}\centering

\textbf{Unit-Propagating Resolution:}
$$
\infer[\upr{i}{\sigma}]
	  {(\jmath_1^i \sigma) \vee \ldots \vee (\jmath_n^i \sigma) \vee 
       (\jmath^i \sigma) \vee (\ell^i \sigma)}
      {\jmath_1^i \vee \ell^i_1 & \ldots & 
       \jmath_n^i \vee \ell^i_n & 
       \jmath^i \vee 
       \overline{\ell'^i_1} \vee \ldots \vee \overline{\ell'^i_n} \vee \ell^i
      }
$$

\bigskip

\textbf{Conflict:}
$$
\infer[\confl{i}{\sigma}]
      {\bot}
      {\ell^i & \overline{\ell'^i}}
$$ 

\bigskip

\textbf{Conflict-Driven Clause Learning:} \\

$$
\infer[\cdcl{i}{p}]
      { \jmath \vee (\overline{\ell^i_1} \sigma^1_1 \vee \ldots \vee \overline{\ell^i_1} \sigma^1_{m_1}) \vee \ldots \vee (\overline{\ell^i_n} \sigma^n_1 \vee \ldots \vee \overline{\ell^i_n} \sigma^n_{m_n})
      }
	  { \infer*{\jmath}
               { \infer*[({\sigma'}_1^1,\ldots,{\sigma'}_{m'_1}^1)]
                      {}{\jmath^i_1} &  &
                 \infer*[({\sigma'}_1^1,\ldots,{\sigma'}_{m'_1}^1)]
                      {}{\jmath^i_m} &  &
                 \infer*[(\sigma_1^1,\ldots,\sigma_{m_1}^1)]
                      {}{[\ell^i_1]^{\dls{p}{1} } } &  &
                 \infer*[(\sigma_1^n,\ldots,\sigma_{m_n}^n)]
                      {}{[\ell^i_n]^{\dls{p}{n}}}
               }
      }
$$ 

где $\jmath = ({\jmath^i_1} \sigma'^1_1 \vee \ldots \vee \jmath^i_1 \sigma'^1_{m'_1}) \vee \ldots \vee ({\jmath^i_k} \sigma'^k_1 \vee \ldots \vee \jmath^i_k\sigma'^k_{m'_k})$

\bigskip

\textbf{Knowledge sharing:} \\

$$
\infer[\kshare{i}{j}]
      {\phi^j}
	  {\phi^i}
$$

где $\phi^a$ --- клоз из актора $a$

\end{calculus}

\caption{Исчисление \emph{Distributed Conflict Resolution}}

\label{fig:DCR}
\end{figure}


% Для того, чтобы задать нашу модель, нам нужно определить: 
% \begin{enumerate}
%     \item Чем именно занимается каждый актор.
%     \item Как акторы передают полученные знания.
%     \item Когда они это делают.
% \end{enumerate}

% Наши акторы будут делиться знаниями. А именно: когда актор получит очередное локальное противоречие, он должен передать его другим акторам для дальнейшего анализа. Давайте введём ориентированный граф на акторах, который будет задавать отношение \textit{кто кому передаёт знания}.

% Далее мы рассмотрим варианты с динамически изменяющимся специалитетом \textbf{TODO: ссылка на соответствующий раздел}.


\textbf{назначим каждому актору множество предикатов, каждый актор это отдельная САДТ, актор получает клоз -- делает предположения по клозам, которые не в его компетенции, пытается вывести боттом, если вывел -- сообщает другим клозам набор предположений, типа что-то из этого точно верно будет, так как по его части противоречие. общаются акторы в какой-то топологии, например по кольцу передают.}

\textbf{пример: два актора, первый отвечает за предикат $A$, второй за предикат $B$, формулы $A \vee B$, $\neg A$, $\neg B$, актор $A$ выведет $B$, отдаст актору $B$, который выведет $\bot$ }


\section{Доказательство refutation полноты}

\subsection{Доказательство для части Бернайса-Шейфенкеля}

% \newtheorem{theorem1}{Theorem1}
% \begin{document}
% \begin{theorem}
% Пусть акторы $A_1,~\ldots,~A_n$
% \end{theorem}
% \begin{proof}
% ИЗИ
% \end{proof}
% \end{document}

\textbf{Теорема: по доказательству из CR можно получить доказательство в Акторах. Доказательсвто: индукция -- смотрим какое действие в выводе было последним, разбираем случаи}

\textbf{Обратно примерно так же}

\subsection{Обобщение на общий случай}

\subsection{Доказательство полноты для исчисления с ограничениями}

\section{Динамическое описание }